# Prefromance

Ох еще один тяжелый для меня раздел, я решил его вскользь упомянуть. Что бы уже просто все затронуть.

## Мы живем в мире органичений

Смотрите, мир полон ограничений. Вы не можете просто так взять и купить биткойны. Или просто скажем получить водительские права (кто то может, но допустим это не вы).

А мир разработке полон ими до нельзя, многое мы устанавливаем сами. К примеру мы говорим что на 3G подключении время загрузки нашей страницы должно быть меньше одной секунды. Окей, и потом пы пытаемся преодолеть это ограничение. Все доходит до разного рода грязных хаков.

И это хророшо. Потому, что нет нет, да и появится светлая голова, которая на основе хаков, решит проблему вообще. К примеру autoprefixer.

Давайте поговорим о производительности страницы.

Все мы по разному относимся к пользователям нашего приложения. Например если мы зависим от колличества пользователей, то мы будем максимально дружелюбны. И приложение у нас будет соответсвтующее. Если мы говорим о бизнеспартнарх, скажем все наши пользователи это работники какой либо компании. Мы можем их заставить пользоваться нашим приложением. То и приложение будет грустным.

Разница только в отношении.

Так вот в первом случае, над перформансем будут карпеть, будет и SSR, и HTTP 2.0 и тп и тд. Возможно не в полном объеме, но в таком кокое позволяет время и силы. И даже анимации оптимизируют.

Во втором забъют. Ничего не будет. К примеру Angular 4 весит 7Mb (дев версия). Угадайте в каком случае его выберут? Правильно, зачем стараться если и так сойдет.

Давайте это и обсудим.

Дорогие любители класть болта на Enterprice проектах, а вы подумали как вы разрабатывать будете? Насолько долго вы будете любоваться на крутящуюся крутелочку, как быстро вы сможете дебажить. И как будет педалить хром при переходах от брэйкпоинта к брэйкпоинту.

Это как экономить на спичках. Мы тут чутка сэкономили на старте, теперь будет терять по 2-3 минуты на каждый релоад страницы. Плюс иметь сложности с дебагом (чем больше кода нужно браузеру интерпритировать тем тежелее ему работать). А если разработчик медленно дебажит в связи со слабым перформансем кода, ну это потери не 2-3 минут, а нескольких часов в день. Плюс на выходе мы имеем злого и уставшего разработчика. А через пару месяцев еще вы выгаревшего. И вот мы уже на 3-ий месяц потеряли половину его продуктивности. ЗБС.

Оптимизировать не сложно, но оптимизации и метрики нужно встраивать в процесс, мы должны задуматься, а нам правда нужен moment-timezone в 300kb? Или может какой костыль решит это проблему также весом в пару 10b?

Смотрите, оптимизируя или хотябы уделяя время оптимизациям, мы получаем более качественный продукт. У нас будут реже возникать ситуации с утечками памяти. Мы будем быстрее дебажить, браузер будет быстрее рендерить.

Мы можем даже оптимизировать анимации. Анимации делают продукт визуальнее более приятнее, а еще прячут наши косяки. Ну камон, разве никто не делал какую всплывучку что бы внимание отвлечь?

Смотрите оптимизации добавляют дополнительные ограничения, с которыми соглашается команда. Это часть культуры. Эти ограничения вкупе со всем остальным будут давать качественный код by default.

К примеру если у вас не SSR, перейти на SSR будет больновато. Но если вы разрабатываете SSR сразу, то разница по скрости разработки +- такая же. Но это дает дополнительные возможности.

К примеру у нас в проде появляется нодовский сервер, который рендерит статику, который может делать еще какую нибудь дополнительную работу. Например кидать во фронтенд скажем глобальные флаги NODE_ENV="X". Что позволит например переключать режимы. Его можно нагрузить еще какой нибудь фронтендовской ерундой, проксированием ресурсов на HTTPS. Да такие себе примеры. Но чет все убежало из головы.

У вас проект рендерится быстрее, ползователь начинает работать с проектом быстрее. И самое главное пропадают из кода прямые обращения к документу. Что не может не радовать. Тоесть хотите, нехотите, но ограничение, что на сервере у вас нету DOM. Это плюс, так как вынуждает писать чуть более абстрактный код. Который опять же платформонезависимый, можно запускать на сервере. Можно переиспользовать.

Для дебага это лучше, для QA лучше, для автоматизированный тестов лучше... Кругом одни сплошные плюсы. А где минусы?

Минусы, это время на миграцию и выстраивание процессов. Да и текущие технологии могу вас тормозить.

HMR, к примеру хоти и отвратительно работает, зачастую для тупых задач, поменять текст, подправить стили, навесить хэндлер. Хорошее решение которое экономит 1 минуту моей жизни. На каждый Cntrl+S. Тоесть HMR продлевает жизнь.

## Webops

Ладно это все конечно хорошо, но важнее ведь скорость сборки. Помните как раньше было ты такой пили 2 часа код. Потом запускаешь сборку, смотришь как она 5 минут собирается. Потом тыкаешь подмечаешь проблеммы. Правишь код. И все таким образом, что бы как можно реже перезапускать сборку проекта.

Чет вспонились плюсы.

На фронте я начал замечать, что во первых если что то у вас тянется не из NPM, а скажем из bower репозитория, из JSPM. То у вас проблемы сир. Во первых все перешли в NPM онли режим. Большинство интсрументов могут либо неработать либо кое как работать с другими репозиториями. У вас будут невероятные трудности по интеграции таких инстрементов в билд. Да и билд будет сложный.

Скорее всего, чанки, вскические конфигурации вы постоянно будете делать вручную. А это высокий уровень ошибок. И очень стремных проблем, которые будут воровать у вас 1-2 дня жизни. А оно вам надо?

В общем на ровне в DesignOps и DevOps. К нам на помощь спешат WebOps. Это ребята которые в сухом остатке оптимизируют билды. И следять за сокростью билдов в CI.

Webpack, хоть и по своему хорош. Но он довольно не тривиален, когда ты садишься его с нуля настраивать или переконфигурировать. Тренд с zeroconifg модулями [cote](https://github.com/dashersw/cote), [lasso](https://github.com/lasso-js/lasso), [rollupjs](https://rollupjs.org/) ... лень искать.

Так вот зачем оптимизировать билды?
Во первых, билд сильно нагружает проц, особенно когда вайлов валом. Притом что, мы же хотим на все файлики watch повесить, и отслеживать измения. А изменения отслеживаются через опрос файловой системы, с каким то маленьким интервалом. Скажем 100ms.

Ну так вот. А мы еще туда линтеров подключим, и еще что нибудь, минификацию трансформацию и тп и тд. А для пущей оптимизации. Мы в RAM это все держать будем.

Когда у вас веб проект билдуется больше 2 минут в 2018 году у нас проблеммы. В идеале 30s или даже меньше должно быть.
Конечно, если мы полагаемся на вебпак очень сильно, нам с него и уйти будет больно. Куда уйти спросите вы, но банально хром идет по пути поддержки [нативный модулей](https://habrahabr.ru/company/tuturu/blog/326716/). С http 2, нам не нужна склейка (условно, всеровно дешевле загрузить 100 файлов чем 1000) и тп и тд. мы можем немного по другому на странице, и получить прогрессивную загрузку из коробки, что максимально эффективно работает на слабеньких девайсах.

Бандлить или не бандлить, а если бандлить то чем вот в чем вопрос. Дискусия следующего года.

Я решил поделиться ссылочками на всякий случай по вского рода оптимизациями, из последнего. Думаю это просто интересно посмотреть.

- [Про производительность Node.js](https://youtu.be/Ns8eOF0Qd1U?list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=25614)
- [Вталя Freedman о rendering оптимизациях](https://youtu.be/Ns8eOF0Qd1U?list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=31131)
- [Об анимациях](https://youtu.be/kqZo-Xmyyss?list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=17216)
- [О дизайне](https://youtu.be/kqZo-Xmyyss?list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=1321)
- [Оптимизации сборки](https://youtu.be/Cprrdyvtirg?list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=1484)
