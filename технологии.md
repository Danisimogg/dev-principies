# Технологии

Немного распишу про технологии, и дам пару тезисов для того, что бы облегчить восприятие текста. Если мы говорим о фронтенде, то за последнее время случился бум фрэйворков, каждый фрэймворк полон как плюсов так и минусов.

Но для начало, что такое фрэймворк. Фронтенд Фрэймоврк - это в первую очередь инструмент который решает задачу управления html, по сути рендерер. Во вторых это инструмент который решает за разработчиков ряд типовых задач: routing, шаблонизатор, управление состояниями, http запросы и прочее, то что разработчики фрэймворка вложили в него.

## О фрэймворках

Как показала практика за последние пару лет, такая идеалогия, что фрэймворк решает за вас все задачи, не жизнеспособна. Во первых, потому что для этого фрэймворк нужно внести, множество абстракций, таких как DI, factory, views, component, lifecircle и тп и тд, скорее всего добавить шаблонизатор, и подвесить обсерверы на все что рисуется шаблонизатором.

Это приводит к тому, что есть сложность:

1. *с подключением сторонних библиотек*, потому что надо привести код библиотеки к фрэймворкопонятному коду.

2. c созданием *высокопроизводительный компонент*, тоесть работать на низком уровне, то абстракции фрэймворка *кажутся неподъемными*. К примеру попробуйте нативно поманипулировать slots, включить, выключить shadow root.

2. *общие подходы*, например к управлению состоянием Redux, Mobx, Flux, Vuex ... *приходится адаптировать вручную*, особенно если комьюнити оч маленькое. А best practice на то и best practice. Что они решают ряд типовых задач и снижают шанс ошибки. Они формируются по мере роста знаний разработчиков о фронтенде. И к сожалению или к радости, их нужно адаптировать к проекту, иначе начнеться стагнация.

3. *сам код шаблонизатора большой*, к примеру в первом ангуляре код шаблонизатора весил соизмеримо со всем остальным кодом фрэймворка. Да и код шаблонов невозможно оптимизировать эффективно, так как это и не HTML и не JS, и мы должны полагаться только на здравомыслие разработчиков.

4. даже в самых боевых условиях, *мы не пользуемся всеми фичами фрэймворка*, но тянем этот багаж за собой в виде бандла. Раньше было модно иметь возможность решить одну и туже задачу разными методами, и фрэймворк поддерживал N методов.

5. *web components*, компоненты уже здесь, база вебкомпонентов растет, но вы не сможете их использовать без довольно хитрого кода, и далеко не все фрэймворки поддерживают все фичи web компонентов. Web компоненты по своей сути убивают все html шаблонизаторы и делают ненужным кучу абстракций фрэймворка. Что бы понять о чем я посмотрите пожалуйста о [Lit HTML](https://github.com/PolymerLabs/lit-html). Это релизнули ребята из polymer тим. Собственно, одна эта либа может заменить целый фрэймворк. Эта либа весит меньше 2kb, голый реакт около 30kb, ангуляр 4 - 7mb, арулия около - 1mb для сравнения. Но это прекрасно иллюстрирует нам куда веб в будующем будет развиваться.

6. *SSR, Codding experience* - практически все фрэймворки так или иначе поддерживают SSR, HMR, и это хорошо. Это позволяет писать код быстрее. Но куда важнее это ошибки, инструменты для работы с фрэймворком. Всякие профайлеры и тп. В большинстве фрэймворков если гдето случается ошибка в шаблоне, ну это твоя проблемма и никаких подсказок.

7. *Дополнительный багаж заний, порог входа*. Вот нельзя сегодня выучить JS и быть молодцом, каждый фрэймворк навязывает идеалогию своих создателей, навязывает дополнительно свой синтаксис. В добавок может быть еще синтаксис шаблонов, хитрые конструкции DI и тп, без который ну ничего ты не сможешь сделать. Довольно мало на чем сегодня можно делать фронтенд и быть близко к нативному скрипту. А чем нативнее тем гибче.

8. *Адаптация к изменениям* - чем сложнее фрэймворк тем он менее поворотлив, несмотря на комьюнити. Вспомним к примеру `phantomjs`, уникальный прокет, миллионы пользователей - один контребьютор. К примеру сейчас модно стало использовать zero config bundler. Сколько фрэймворков поддерживают такую опцию? Лично я знаю 2.

На сегодняшний день нету идеального фрэймворка, отсюда и холивары. Так как каждый хочет продать свою вандервафлю подороже. И нанять разработчиков подешевше. Но за все нужно платить.

Я хочу заметить то, что важно смотреть на тренды развития технологий, куда мы идем. Каким будут веб технологии в следующем году. И знаете, что. В 2018 году нам не нужны фрэймворки.

Нам нужны библиотеки, к примеру React.js, Polymer.js, и тп... Либо гибриды, Vue.js. Даже старые монструозные фрэймворки, такие как Angular, распиливаются на модули, и пытаются быть похожи на библиотеки. Почему? Потому, что вы решая свою задачу берете, те инструменты которые подходят именно вам.

Даже более для работы на фронтенде с данными, а именно: получение данных с сервера, форматрирование, отрисовка, а так же работа с пользовательскими событиями. Нам для этого ненужно OOP.

Что нам дают классы? Выразительность в коде, и вприципе все. А по минусам целый вагон, начиня с того, есть ряд кейсов когда нельзя написать декоратор и навесить на функцию класса, потому что невозможно отловить момент создания контекста. Порождает ряд сложностей как с тестированием так и появляется необходимость в DI, к примеру Aurelia, Angular. Да и фрэймворк зачастую использует эти классы как синглтоны. Мы даже можем не замечать ряд сложностей с классами, которые решаются в глубинах фрэймворка, но обычно рано или поздно появляется кейс, когда это оч сильно стреляет в ногу.

В общем функциональное программирование на фронтенде прочно заняло свое место, нравиться кому это или нет. Да, безусловно и в React и во Vue, можно писать с помощью классов компоненты, но зачем? Потом сложно делать декомпозицию, если вдруг кода много. Мое мнение во многом совпадает с Алексем Золотых [Архитектурные Этюды](https://www.youtube.com/watch?v=OuEilDv3WNo&feature=youtu.be&list=PL8sJahqnzh8LB_kh1bmnJ9uXjwZEoKQVj&t=672), там на очем примитивном примере можно посмотреть почему функции лучше.

Мой топ 3 фрэймворков на начало года в порядке любви, за прошлый год я успел пописать на 6 разных фрэймворках, решая бизнес задачи разного уровня сложности. Но примерно имеющие много общего:

### 1. Реакт

В целом ничего удивительного, что он N1 в списке, за этот год реакт расцвел. Документация стабилизировалась, по ней теперь можно хотябы понимать текущее состояние вещей. Сам Реакт улучшился, убрали ряд досадных косяков, добавили много фишек из vue. Даже появился zero config creat-react-app, который вполне годный, появились namespaces в yarn.

Самое бурноразвивающиеся комьюнити, оведофига всяческих либ, модулей и плагинов. По сути Реакт можно собрать и пропатчить так, что можно получить все фишки любого фрэймворка. Но тут то и сложность. Но не суть. Важно то, что на реакт переводят свои проекты как динозавры IT, так и корпорации, со стартапами.

А еще они не гнушаются и делятся опытом и best практиками с нами убогими. Да и зачастую порождают ряд замечательных библиотек и плагинов, которые ну просто нельзя не пощупать.

Самое главное вы должны понимать, инфраструктура React оч огромна, и она будет расти и развиваться дальше засчет маркетинга проводимого в facebook. Эвентов и тп и тд. Банально сходите на любой фронтенд эвент опросите людей и узнаете, что оч много пишут на react % 50, процентов 10-20% на какомто no name говне, а остальные на angular / ember / jquery / RoR и тп.

И вот я замечаю те кто пишут на react далеко не новички в IT.

Я даже попробовал писать без фрэймворков минисайтик, и через какое то время заметил что мой код, сильно начал напоминать react. Ближе к lit-html, но все же.

### 2. Vue

Вью хорош комьюнити, оно действительно прекрасно, там масса замечательных людей. Самая лучшая дока которую я видел, плюс подкупает перформанс. Но есть большой минус, vue это фрэймворк, и сама декларация компонент - это структура. Структурный код одинаково неприятно писать и читать. Из-за того что vue фрэйворк, он позволяте решать задачи намного проще чем React, плюс он имеет свой набор коровых библиотек, которые позволяют получить реактивность лучшую с меньшими усилиями чем у React. Вы даже можете использовать vue вместе с jsx, писать рендер функции.

Но все, все что не рекомендованный синтаксис, способ написания и тп и тд. Рискует погибнуть или привести к ряду проблемм, когда мажор вью обновиться.

Резюмируя vue достаточно хорош, что бы его использовать, но он не дает ту гибкость и скорость в написании кода которую дает react. Если сравнить vue файлы и jsx файлы, то jsx более понятен и для понимания. Как сравнивать html first или js first.

По факту, вью мало чем таким отличается от polymer 1,2 синтаксически.

Из хороших плюшек, самые приятные инструменты, подсветка синтаксиса, и подсказка ошибок в шаблонах. Тут жирный плюс.
Ну и огромный плюс, если вы не выпендриваетесь, это вхождение в фрэймворк, очень прост, и любой джун разберется за неделю.

### 3. Polymer 3 ???

Мне очень нравиться идеалогия полимера, у него хорошая база компонент была. Плюс `lit-html` мне очень нравится, но он еще в альфе, компоненты все еще портируются со второго полимера, да и врядли стоит брать в продакшн, либу, которая не так давно смигрировала с bower на npm. Так как они решили двигаться по пути React & Vue тоесть js first. Где у вас будут нормальные JS модули, и паралельно в гугле они форсят ряд фич в хромиум.

На выходе может получиться оч крутая либа вокруг которой вырастет крутая инфраструктура, но это дело будующих лет. Сейчас это хороший инструмент внутри гугла, и никому из вне не советую на нем что либо серьезное делать. Надоест мигрировать, обновлять и саппортить код.

Да и маркетинг у полимера хуже некуда, им все еще предстоит продать его большей части разработчиков.

## О стилях

Сейчас нет смысла использовать CSS препроцессоры. CSS пропертис, практически полностью закрыват все то что нам давал SASS / LESS / Stylus. Их глобальное использование, позволяет выгенеривать темы на лету, и переключать их, без мигания страниц. Тоесть make sence.

Помимо всего прочего если мы дропаем препроцессоры, у нас упращается билд, нам нет необходимости изучать и погружаться в доп синтакси, это как coffee скрипт. Надо просто дать им уйти спокойно.

Дальше больше, если мы используем shadow-root, то у нас стили изолированные по умолчанию от внешних стилей. И уже случайно каким то глупым слелектором вестку не поломать. Но это и меняет работу со стилями в принципе, так как пропадает возможность использовать глобальные стили. Если у вас старый код, его будет тяжело мигрировать. Если вы хотите использовать bootstrap.css забудьте.

Как аналогия с shadow-root, но менее суровая, это styled component. Когда у вас ко всем классам дописывается некий хэш, и посути изолирует стили таким образом, врядли вы случайно напишите селектор с рандомным хэшом. Это довольно удобно, так как мы все еще можем использовать глобальные слити, но теперь мы их навешиваем явно. И в коде сразу видно что ага это глобальные, это локальные.

На мой взгляд второй способ предпочтительнее, так как он нам позволяет использовать много старого проверенного кода. Без необходимости велосипедить.

Само собой и в первом и во втором случае, нам было бы хорошо использовать autoprefixer. Поэтому без postcss никуда. Но я бы не стал сильно намешивать туда плагинов, в попытках упростить написание кода. Так как это повысит сложность входа в проект.

Я бы не стал забывать про BEM & Atomic дизайн, этому просто обучить, это позволяет повысить качество и сделать код однороднее на ровном месте.

## О всякого рода линтерах

Я негативно отношусь к линтингу, typescript, coffeesrypt, ext.js. Чем плох линтинг? А он не плох, зачастую особенно в outsoursing компаниях, и в overcorporated компаниях его очень любят. Сразу находятся инжинеры которые пишут строжайший гайд из 100 пунктов, подвешивают это все дело в сборку проекта, и еще какую нибудь нотификашку вешают, что бы выпрыгивала нативно в OS с каким либо звуком.

Проблемма в том, что у нормального девелопера уже в самой среде разработки, неважно Sublime Text, WebStorm, Visual Code или Vim, будет стоять линтер. Нет смысла вешать его в рантайм сборку в дев режиме. Хук перед комитом еще ладно, он не так сильно раздражает.

Просто смотрите, вы пишите код, зачастую первый драфт, набросок функциональности будет плох. Вы эксперементируете, вы находитесь в потоке, и тут вас начинает отвлекать навязчивый линтер, вы возможно отвлечесь и даже подправите код. Но это лишнее действие которое имеет 0 ценности для компании.

Да и нет смысла в строгом линтере. Если только вы не планируете рефакторить регулярками и автозаменами. Но и тут, вы можете навесить строгий линтер на ключевые моменты, например многие не используют `exports default something` конструкцию, так как она пораждает сложности в рефакторинге.

Ок вы ввели такое правило написали линтер. Но тогда было бы неплохо еще позаботиться о сотрудниках и помочь им встроить это правило в среду разработки. На самом деле это только звучит сложно. Если у вас всеже строгий линтер, помогите всем, напишите плагин для автоформатирование под него. Врядли какой либо сторонний разработчик сделал это за вас.

Практически все тоже касается и `typescript`. К примеру я не нашел кейсов где бы я вот не смог обойтись без него. Тоесть вот я не смог найти той дельты, что бы мог сказать, да вот тут мне помогает типизация. Притом такая типизация когда ты большую часть времени пишишь `any`, особенно меготупо для итераторов. Да `typescript` можно использовать в light режиме выключив 70% валидаций. Но если вы пишите в функциональном стиле, он всеровно ругается на ряд конструкций, которые вполне себе валидны, но для typescript нет. Единственный способ это делать игнор в таких местах.

Да и вообще если мы говорим о типах и других яызыках. `Typescript` это другой язык, как `coffescript`. Так вот `Dart` справляется с это задачей в миллион раз лучше, у него своя виртуальная машина, которая дает невероятный `codding experience`. Да `Dart` не такой пропеаринный как `typescript`, но задачи с автокомплитом и подсказку ошибок на этапе компиляции дает лучше.

Да и вообще типизации нужна если вы пишите фрэймворк, у вас хитрая бизнеслогика, вы занимаетесь магией. Так вот используйте ее там, оставьте остальной код в покое. Для этой задачи подходит лучше всего `flow.js`.

И последнее, я провел опрос среди разработчиков которыми я восхищаюсь, так вот, людям либо навязали `typescript`, они недовольны но пользуются. Когда у них есть свобода выбора они им не пользуются, с вопросами зачем он мне.

"нужна типизация - берем флоу.
 но мы спокойно на жсдоках обходимся. все что нужно типизировать это только утилитарные и общие штуки но основная часть бизнеслогики это не универсальная фигня. так что типизация там просто ни к чему. жсдоки охрененно линтят типы, и подсветка и все плюшки типизации есть" - коментарий одного из разработчиков.

## Выводы

Резюмируя текст выше, мы должны в конце то концов отказаться от frameworks в пользу класических библиотек. Помните jquery? Так вот это вторая волна. На сегодняшний момент webbrowser внутри себя решил много задач, мы знаем что такое slots, shadow dom, у нас есть CSS values, es6, es7 и бабель.

В идеальном мире мы должны максимально нативно писать код, максимально нативный HTML, максимально нативный CSS, максимально нативный JS. Минимизируя фрэймворкозависимый код, только так мы можем гарантировать себе безболезненное будующее на современных технологиях.

Тендеция такова, что фрэймворк на сегодняшний день - это `html renderer`, и набор opensource кода вокруг него. Чем больше, тем лучше.

Бессмысленно использовать строгие линтеры, или еще хуже использовать линтеры и подвид языка `typescript`, `coffeescript`. Вы вываливаетесь в более мелкое комьюнити, хотите типизацию, подсветку ошибок компиляции. Обратите внимание на `dart`, хотите сделать себе удобный автокомплит, и типы в сложных местах приложения используйте `flow.js`.