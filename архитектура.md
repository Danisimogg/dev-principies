# Архитектура

Ключевое место занимает архитекрута. Если вы ознакомились с главой один - **технологии**, то уже знаете что будующее веба это билиотеки а не фрэймворки.

И тут самое смешное. Для того, что бы проект не загнулся и не привратился в полное говно. Нам нужен архитектор, webops, и ряд консультанотов. Хек, я шучу. Нам достаточно сесть и пораскинуть мозгами.

Во главе всего стоит **webpack**, хороший он или плохой - неважно. Лучше него ничего на сегодняшний день нету. Притом он себя очень хорошо зарекомнедовал себя в больших и очень больших компаниях. Конфигурировать его с нуля дело неприятное и зачастую геморойное. Как же хорошо что у нас есть гитхаб, есть миллион статей о том как его готовить. Так что найти +- нужный конфиг труда не составит. А дальше время от времени его подпиливать это уже дело всей команды.

Хорошей практикой я считаю это время от времени пытаться оптимизировать билд, или встроить утилиту замеров производительность билдов, но об это давайте поговорим позже.

## Data Flow

Так получилось, что мне эта тема была интересна пару лет назад и я ковырялся в разного рода проектах, в поисках идельной архитектуры.

Собственно основной косяк который лежит впринципе на поверхности, и о котором исчесали языки ораторы на всяческих метапах - это данные и работа с данными. Собственно весь UI это разговор об управлении данных и их отображение. Вроде все просто. Но это на самом деле просто.

Неважно какие у вас данные, сложные, супер сложные. Тяжелые, легкие. Аудио, видео. Все это не имеет значение. Важно понимать и жостко контролировать потоки данных. Если просто, представьте людей в метро. Они заходят на одной станции, проходят с одной станции на другую, через какой то переход, садяться в вагон кудато едут. Потом поднимаясь на эскалаторе, выходят из метро.

Так вот у людей в метро нет особого выбора как действовать находясь внутри метро. Парень не может к примеру взять телефон, позвонить машинисту, попросить подъехать через 5 минут. Или телепортироваться со станции на станцию. Или скажем сесть на станции в машину и поехать быстрее чем ходят поезда.

Кажется, что описанна бредовая ситуация. Но в коде мы себе такое частенько позволяем с данными. Покрайней мере те 50 проектов которые я отсмотрел, имели именно такое поведение. Полный хаос и анархия при работе с данными.

А данные как солдаты в армии, любят порядок. У вас в проекте должен быть один способ, взять данные. Единый сценарий по трансформации данных, если это необходимо. А так же единый способ рендеринга данных.

Собственно вся бизнес логика приложения должна быть реализована гдето здесь. Скажем все единым образом.

К примеру если изначально было принято грузить данные через сервисы, напрямую во вьюху. И там уже совершать всяческие преобразования, закидывать данные в компонент. Который внутри себя может еще сходить на backend, за дополнительными данными. Мы же как бы вынесли все вызовы АПИ в некий сервис, вроде абстракция. Значит, мы можем себе такое позволить, думает большинство разработчиков.

Но нет. Так нельзя, это пораждает спагетии код, который тяжело понять. Который ведет себя непредсказуемым образом. Повышает время необходимое на внесение изменений.

Самое худшее что я видел, это подобный UI, где еще все вызовы апи происходили через глобальные эвенты. Все на эвентах, не тех эвентах компонента, а нативных DOM эвентах. Где АПИ метод вызываясь в одном месте, мог породить еще десятки вызвовов методов и АПИ в совершенно непредсказуемых местах, за счет всплытия и баблинга. Банальный дебагинг такого спагетти мог занимать день. О какой либо реактивной разработке и речи идти не могло.

## Fetch - formatter - store - component

Самое лучшее на мой взгляд решение. Оно же самое популярное. Это использовать серелизуемый стор как прокси между экшенами приложения и рендерером компонента.

Я могу изобразить этот паттерн используя даже текстовые сиволы в редакторе:

JS Objects \                               / component
Sockets --- -- adapters - store - app --  -- component 2
Fetch --/                                  \ component 3

Казалось бы все очевидно, но не для всех. На всякий случай если вы пропустили развитие фронтенда с 2016 года. Давайте пройдемся слева на права.

Мы видим, что у нас есть источники данных, нам обсолютно неважно, что это. Это нативные JS объекты, это какието данные из сокетов, это HTTP request, или сам господь бог.

Давайте назовем это все экшенами, которые принимат параметры на вход и возвращают, либо результат в виде JS примитивов + Object. Либо промис. Посути это атомарные функции, которые гдето берут данные и отдают их нам дальше.

После мы можем написать абстракцию, которая будет брать данные, и приводить их к какомуто итоговому виду. Возможно у нас разработчики на бэкенде ленивые, что бы вернуть данные в формате который нам нужен здесь и сейчас. Возможно мы слишком требовательные. Назовем эту абстракицю - adapters. Они нужны для реализации простой идеи. В строе должны лежать только итоговые данны, которые больше нигде не надо приводить к нужному виду.

Смотрите, когда у нас копяться адаптеры, в одном месте. Это удобно. Мы всегда можем оптимизировать перформанс в дальнейшем, закинув эту логику на бэкенд. Например в тот момент, когда бэкендщики будут халявить и мы их спалим на этом.

Второй плюс, мы не размазываем логику преобразований данных по всему приложению, и это делает код более читабельным и дружелюбным.

Гдето в сторе мы делаем мутации, данных, или просто перетераем их. Тут уже от задачи. Важно что бы стор оставался сериализуемым. Что бы его состояние можно было посмотреть в девтулзе и сделать **timelapse**.

Первое очень помогает при дебагинге или разработке новых фичей, вы можете игнорировать то что вам приходит с API, так как внутри приложения вы работаете с тем что берется из стора. А мы уже договорились, что там данныех красивые и хорошие.

И во вторых мы легко можем поресерчить, на тему а есть ли у нас где такие данные. Без необходимости лезть в неатуальную доку, или искать сертифицированного бэкендера.

Второе, мне очень нравится. Вы можете разрабатывать приложение без необходимости делать N нудных шагов для получения данных. Их можно застабить в стэйт. При некой договоренности с тестировщиками, вам не надо вчитываться в steps to reproduce. А им их описывать или скринить. Они могут просто прикрепить текущий стэйт приложения к багу. И вуаля. У вас приложение открывается в нужном месте, с тем самым состоянием что и у тестера. Я немогу представить как быстрее перейти непосредственно к исправлению бага или дебагингу, без этой фичи.

Я думаю тут можно еще много чего придумать, было бы желание. Как пример, выгенеривать автоматизированные тесты. Которые вгружают стэйт и смотрять, все хорошо или нет.

Последнее это компоненты, тоесть у нас все приложение, именно то которое сейчас отрисованно, подписанно на стор и его изменения.
Тоесть описывать бизнес логику теперь просто. У нас есть атомарные экшены. Которые ложат данные в стор. Нам важно для бизнес логики дернуть N экшенов, и отобразить данные вот так. После того как пользователь заполнил форму и кликнул. Мы дернули вот такой экшен, ну и дальше еще что нибудь.

Важно что, мы можем сделать централизованную работу с ошибками. Мы можем сделать централизованную валидацию форм. Этого легко добиться, продумав то как приложение будет реагировать на данные, и что должно быть в сторе что бы показать это или это...

Возможно я написал это сложно, приплев кучу ненужных обстракций, вызвав у вас полное недопонимание. [Вот тут все расписанно доступным русским языком с картинками](https://vuex.vuejs.org/ru/intro.html)

## Componet - receive data - return event

Мне очень нравиться идея однонаправленного потока данных, потому что когда у тебя есть выбор между подпиской на обсвервер в проперти или подпиской на евент. Большинство выбирает 1-е. Привет ребята из Ангуляра или Арелии. Это приводит к компонентам, которые не имеют эвентов. Да и сомнительному коду, котрый следит за изменениями проперти.

Представьте что компонент это функция, в которые есть входные параметры - это проперти, и выходные параметры - это эвенты. Легко объяснить. Собственно и вся идея. [Вот тут про это хорошо написанно, опять же грамотным русским языком](https://ru.vuejs.org/v2/guide/components.html#%D0%9E%D0%B4%D0%BD%D0%BE%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

## Decorators

Смотрите, уже 2018 год на носу, и впринципе можно небояться декораторов. Можно начинать их использовать, они действительно повышают читабельность кода. Многие типовые штуки, рутиныне можно вынести в декораторы.

К примеру вы заметили, что скажем у вас во вьюшках встречается примерно один и тот же, код. Код важный, он нужен для чегото ключевого. Круто, сделайте декоратор. Дайте ему внятное имя. Вынесите туда этот код. Теперь используйте этот декоратор для всях подобных вьюшек. Главное 1-н декоратор, решает одну задачу, все еще пишим атомарно, придерживаемся SOLID.

Чем хороши декораторы. Они заменяют миксины, которые популярны во Vue.js. Они решают проблемму множественного наследования. А так же позволяют сделать код более выразительным.

И занете что. [Все хорошее уже написанно за нас](https://github.com/jayphelps/core-decorators)

## Observers

Кому как, но мне нравятся обсерверы. Почему, потому что я ленивый человек. Я не хочу все делать функционально, дергать важные методы руками. И бороться за каждый бит оперативки пользователя. Потому что основаня наша задача, это сделать продукт который приносит $. $ бабло - которое потом - $$ делает больше бабла.

Вот любую работу которую вы можете автоматизировать - автоматизируйте. Фокусируйтесь на важных задачах.

К примеру в React, мне понравился [https://mobx.js.org/](MobX), действительно удобно и понятно. Убирает лишнюю возню при работе с данными. При меньшем ручном коде мы получаем тот же профит.

"Возможно по такому небольшому обзору это не очень понятно, но mobx/mobx-react действительно очень полезная вещь, и она набирает популярность. Если вам знакома боль от кучи экшнов/редьюсеров redux-а и большого количества boilerplate кода в компонентах то посмотрите на mobx. Мы его начали использовать в крупном проекте пол года назад и не только уменьшили количество кода в целом, но и сделали его более доступным для понимания новых разработчиков разного уровня. Готов поделиться подробностями, если кому интересно, без смс и регистрации" - Цитата какого то разработчика.

В общем голый Redux, порождает кучу однотипного кода, который вприцнипе мы можем выгенеривать декораторами. А так же у redux болезнь, у вас либо мало компонентов подписаны на единственный стор и тогда у вас боль с пробрасыванием данных через props или context, либо подписано много компонентов и тогда на каждый чих стора у вас… тадам — ре-рендеры, которые надо вручную обходить через shouldComponentUpdate. Вот чтобы избавить от этой боли и был создан mobx, и это не имеет ничего общего с ужасом типа Knockout, имхо.

В общем очень приятная либа, да и с обсерверами больше плюсов чем минусов, если вдумчиво их использовать.